import { checkAudioQuality, getAudioQualitySuggestions, isSuitableForSpeechRecognition, preprocessAudio } from '@/utils/audioQualityChecker';
import { diagnoseBaiduSpeechIssues } from '@/utils/baiduSpeechApi';
import { checkSpeechRecognitionPermission, convertSpeechToText, diagnoseSpeechRecognition, getSpeechRecognitionConfigInfo, getSpeechRecognitionStatus } from '@/utils/speechToText';
import { Ionicons } from '@expo/vector-icons';
import { Audio } from 'expo-av';
import React, { useEffect, useMemo, useState } from 'react';
import { Alert, Animated, Platform, Pressable, StyleSheet, TouchableOpacity } from 'react-native';
import { ThemedText } from './ThemedText';

interface VoiceInputProps {
  onVoiceResult: (text: string) => void;
  disabled?: boolean;
}

export default function VoiceInput({ onVoiceResult, disabled = false }: VoiceInputProps) {
  const [isRecording, setIsRecording] = useState(false);
  const [isProcessing, setIsProcessing] = useState(false);
  const [recording, setRecording] = useState<Audio.Recording | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [hasPermission, setHasPermission] = useState<boolean | null>(null);
  const [speechStatus, setSpeechStatus] = useState<{
    baiduAvailable: boolean;
    fallbackAvailable: boolean;
    primaryService: string;
  } | null>(null);
  const [configInfo, setConfigInfo] = useState<any>(null);
  const [diagnosis, setDiagnosis] = useState<any>(null);
  const [lastRecordingUri, setLastRecordingUri] = useState<string | null>(null);
  const [isPlaying, setIsPlaying] = useState(false);
  const [sound, setSound] = useState<Audio.Sound | null>(null);
  const [baiduDiagnosis, setBaiduDiagnosis] = useState<any>(null);
  const pulseAnim = useMemo(() => new Animated.Value(1), []);

  useEffect(() => {
    // Ê£ÄÊü•ÂΩïÈü≥ÊùÉÈôê
    (async () => {
      try {
        const permission = await checkSpeechRecognitionPermission();
        setHasPermission(permission);
        
        if (!permission) {
          console.log('‚ö†Ô∏è ÂΩïÈü≥ÊùÉÈôêÊú™Êéà‰∫à');
          setError('ÈúÄË¶ÅÂΩïÈü≥ÊùÉÈôêÔºåËØ∑Âú®ËÆæÁΩÆ‰∏≠ÂÖÅËÆ∏‰ΩøÁî®È∫¶ÂÖãÈ£é');
        } else {
          console.log('‚úÖ ÂΩïÈü≥ÊùÉÈôêÂ∑≤Êéà‰∫à');
          setError(null);
        }
      } catch (error) {
        console.error('‚ùå ÊùÉÈôêÊ£ÄÊü•Â§±Ë¥•:', error);
        setHasPermission(false);
        setError('ÊùÉÈôêÊ£ÄÊü•Â§±Ë¥•');
      }
    })();

    // Ê£ÄÊü•ËØ≠Èü≥ËØÜÂà´ÊúçÂä°Áä∂ÊÄÅ
    (async () => {
      try {
        const status = await getSpeechRecognitionStatus();
        setSpeechStatus(status);
        console.log('üé§ ËØ≠Èü≥ËØÜÂà´ÊúçÂä°Áä∂ÊÄÅ:', status);
      } catch (error) {
        console.error('‚ùå Ëé∑ÂèñËØ≠Èü≥ËØÜÂà´ÊúçÂä°Áä∂ÊÄÅÂ§±Ë¥•:', error);
      }
    })();

    // Ëé∑ÂèñÈÖçÁΩÆ‰ø°ÊÅØ
    try {
      const config = getSpeechRecognitionConfigInfo();
      setConfigInfo(config);
      console.log('üîß ËØ≠Èü≥ËØÜÂà´ÈÖçÁΩÆ‰ø°ÊÅØ:', config);
    } catch (error) {
      console.error('‚ùå Ëé∑ÂèñÈÖçÁΩÆ‰ø°ÊÅØÂ§±Ë¥•:', error);
    }
  }, []);

  useEffect(() => {
    if (isRecording) {
      Animated.loop(
        Animated.sequence([
          Animated.timing(pulseAnim, {
            toValue: 1.2,
            duration: 1000,
            useNativeDriver: true,
          }),
          Animated.timing(pulseAnim, {
            toValue: 1,
            duration: 1000,
            useNativeDriver: true,
          }),
        ])
      ).start();
    } else {
      pulseAnim.setValue(1);
    }
  }, [isRecording, pulseAnim]);

  // Êí≠ÊîæÂΩïÈü≥
  const playRecording = async () => {
    if (!lastRecordingUri) {
      Alert.alert('Ê≤°ÊúâÂΩïÈü≥', 'ËØ∑ÂÖàÂΩïÂà∂‰∏ÄÊÆµÈü≥È¢ë');
      return;
    }

    try {
      setIsPlaying(true);
      
      // ÂÅúÊ≠¢ÂΩìÂâçÊí≠Êîæ
      if (sound) {
        await sound.unloadAsync();
      }

      // ÂàõÂª∫Êñ∞ÁöÑÈü≥È¢ëÊí≠ÊîæÂô®
      const { sound: newSound } = await Audio.Sound.createAsync(
        { uri: lastRecordingUri },
        { shouldPlay: true }
      );

      setSound(newSound);

      // ÁõëÂê¨Êí≠ÊîæÂÆåÊàê
      newSound.setOnPlaybackStatusUpdate((status) => {
        if (status.isLoaded && status.didJustFinish) {
          setIsPlaying(false);
        }
      });

      console.log('üîä ÂºÄÂßãÊí≠ÊîæÂΩïÈü≥:', lastRecordingUri);
    } catch (error) {
      console.error('‚ùå Êí≠ÊîæÂΩïÈü≥Â§±Ë¥•:', error);
      setIsPlaying(false);
      Alert.alert('Êí≠ÊîæÂ§±Ë¥•', 'Êó†Ê≥ïÊí≠ÊîæÂΩïÈü≥Êñá‰ª∂');
    }
  };

  // ÂÅúÊ≠¢Êí≠Êîæ
  const stopPlaying = async () => {
    if (sound) {
      try {
        await sound.stopAsync();
        await sound.unloadAsync();
        setSound(null);
        setIsPlaying(false);
        console.log('‚èπÔ∏è ÂÅúÊ≠¢Êí≠ÊîæÂΩïÈü≥');
      } catch (error) {
        console.error('‚ùå ÂÅúÊ≠¢Êí≠ÊîæÂ§±Ë¥•:', error);
      }
    }
  };

  // ËØäÊñ≠ÁôæÂ∫¶ËØ≠Èü≥API
  const diagnoseBaiduAPI = async () => {
    try {
      console.log('üîç ÂºÄÂßãËØäÊñ≠ÁôæÂ∫¶ËØ≠Èü≥API...');
      const diagnosis = await diagnoseBaiduSpeechIssues();
      setBaiduDiagnosis(diagnosis);
      
      // ÊòæÁ§∫ËØäÊñ≠ÁªìÊûú
      const message = diagnosis.recommendations.join('\n');
      Alert.alert('ÁôæÂ∫¶ËØ≠Èü≥APIËØäÊñ≠ÁªìÊûú', message);
      
      console.log('üìã ÁôæÂ∫¶ËØ≠Èü≥APIËØäÊñ≠ÁªìÊûú:', diagnosis);
    } catch (error) {
      console.error('‚ùå ËØäÊñ≠Â§±Ë¥•:', error);
      Alert.alert('ËØäÊñ≠Â§±Ë¥•', error instanceof Error ? error.message : 'Êú™Áü•ÈîôËØØ');
    }
  };

  const startRecording = async () => {
    if (disabled) return;

    // Ê£ÄÊü•ÊùÉÈôê
    if (!hasPermission) {
      Alert.alert(
        'ÈúÄË¶ÅÂΩïÈü≥ÊùÉÈôê',
        'ËØ∑Âú®ËÆæÁΩÆ‰∏≠ÂÖÅËÆ∏Â∫îÁî®‰ΩøÁî®È∫¶ÂÖãÈ£éÔºåÁÑ∂ÂêéÈáçËØï',
        [
          { text: 'ÂèñÊ∂à', style: 'cancel' },
          { text: 'ÂéªËÆæÁΩÆ', onPress: () => {
            // Âú®iOS‰∏äÂèØ‰ª•ÊâìÂºÄËÆæÁΩÆ
            if (Platform.OS === 'ios') {
              // ËøôÈáåÂèØ‰ª•Ê∑ªÂä†ÊâìÂºÄËÆæÁΩÆÁöÑÈÄªËæë
            }
          }}
        ]
      );
      return;
    }

    try {
      setError(null);
      setDiagnosis(null);
      await Audio.setAudioModeAsync({
        allowsRecordingIOS: true,
        playsInSilentModeIOS: true,
      });

      // ‰ΩøÁî®‰ºòÂåñÁöÑÂΩïÈü≥ËÆæÁΩÆÔºåÁ°Æ‰øùÈ´òË¥®ÈáèÈü≥È¢ë
      const { recording } = await Audio.Recording.createAsync({
        android: {
          extension: '.wav',
          outputFormat: 1, // PCM_16BIT
          audioEncoder: 1, // PCM_16BIT
          sampleRate: 16000, // ÂåπÈÖçÁôæÂ∫¶APIË¶ÅÊ±Ç
          numberOfChannels: 1, // ÂçïÂ£∞ÈÅì
          bitRate: 256000, // È´òË¥®ÈáèÊØîÁâπÁéá
        },
        ios: {
          extension: '.wav',
          outputFormat: 1, // LINEARPCM
          audioQuality: 2, // MAX - ÊúÄÈ´òË¥®Èáè
          sampleRate: 16000, // ÂåπÈÖçÁôæÂ∫¶APIË¶ÅÊ±Ç
          numberOfChannels: 1, // ÂçïÂ£∞ÈÅì
          bitRate: 256000, // È´òË¥®ÈáèÊØîÁâπÁéá
          linearPCMBitDepth: 16, // 16‰ΩçÊ∑±Â∫¶
          linearPCMIsBigEndian: false,
          linearPCMIsFloat: false,
        },
        web: {
          mimeType: 'audio/wav',
        },
      });
      
      setRecording(recording);
      setIsRecording(true);
      console.log('üé§ ÂºÄÂßãÂΩïÈü≥...');
    } catch (err) {
      console.error('‚ùå ÂΩïÈü≥Â§±Ë¥•:', err);
      setError('ÂΩïÈü≥Â§±Ë¥•ÔºåËØ∑ÈáçËØï');
      Alert.alert('ÂΩïÈü≥Â§±Ë¥•', 'Êó†Ê≥ïÂºÄÂßãÂΩïÈü≥ÔºåËØ∑Ê£ÄÊü•È∫¶ÂÖãÈ£éÊùÉÈôê');
    }
  };

  const stopRecording = async () => {
    if (!recording) return;

    setIsRecording(false);
    setIsProcessing(true);
    
    try {
      console.log('üõë ÂÅúÊ≠¢ÂΩïÈü≥...');
      await recording.stopAndUnloadAsync();
      const uri = recording.getURI();
      setRecording(null);

      if (uri) {
        console.log('üìÅ ÂΩïÈü≥Êñá‰ª∂URI:', uri);
        setLastRecordingUri(uri); // ‰øùÂ≠òÂΩïÈü≥Êñá‰ª∂URI
        
        try {
          // È¢ÑÂ§ÑÁêÜÈü≥È¢ëÊñá‰ª∂
          const processedUri = await preprocessAudio(uri);
          console.log('‚úÖ Èü≥È¢ëÈ¢ÑÂ§ÑÁêÜÂÆåÊàê');
          
          // Ê£ÄÊü•Èü≥È¢ëË¥®Èáè
          const audioQuality = await checkAudioQuality(processedUri);
          console.log('üéµ Èü≥È¢ëË¥®ÈáèÊ£ÄÊü•:', audioQuality);
          
          if (!isSuitableForSpeechRecognition(audioQuality)) {
            const suggestions = getAudioQualitySuggestions(audioQuality);
            console.log('‚ö†Ô∏è Èü≥È¢ëË¥®ÈáèÂª∫ËÆÆ:', suggestions);
            setError(suggestions[0] || 'Èü≥È¢ëË¥®Èáè‰∏çÈÄÇÂêàËØÜÂà´ÔºåËØ∑ÈáçÊñ∞ÂΩïÈü≥');
            return;
          }
          
          // ËøõË°åËØäÊñ≠
          const diagnosisResult = await diagnoseSpeechRecognition(processedUri);
          setDiagnosis(diagnosisResult);
          console.log('üîç ËØäÊñ≠ÁªìÊûú:', diagnosisResult);
          
          // Ë∞ÉÁî®ËØ≠Èü≥ËΩ¨ÊñáÊú¨ÂäüËÉΩ
          console.log('üîÑ ÂºÄÂßãËØ≠Èü≥ËØÜÂà´...');
          const recognizedText = await convertSpeechToText(processedUri);
          
          if (recognizedText) {
            console.log('‚úÖ ËØ≠Èü≥ËØÜÂà´ÊàêÂäü:', recognizedText);
            onVoiceResult(recognizedText);
            setError(null);
          } else {
            console.log('‚ùå ËØ≠Èü≥ËØÜÂà´ÁªìÊûú‰∏∫Á©∫');
            setError('Êó†Ê≥ïËØÜÂà´ËØ≠Èü≥ÂÜÖÂÆπÔºåËØ∑ÈáçÊñ∞ÂΩïÈü≥');
          }
        } catch (error) {
          console.error('‚ùå ËØ≠Èü≥ËØÜÂà´Â§±Ë¥•:', error);
          setError(error instanceof Error ? error.message : 'ËØ≠Èü≥ËØÜÂà´Â§±Ë¥•ÔºåËØ∑ÈáçËØï');
        }
      } else {
        console.log('‚ùå ÂΩïÈü≥Êñá‰ª∂URI‰∏∫Á©∫');
        setError('ÂΩïÈü≥Êñá‰ª∂ÁîüÊàêÂ§±Ë¥•');
      }
    } catch (error) {
      console.error('‚ùå ÂÅúÊ≠¢ÂΩïÈü≥Â§±Ë¥•:', error);
      setError('ÂΩïÈü≥Â§ÑÁêÜÂ§±Ë¥•');
    } finally {
      setIsProcessing(false);
    }
  };

  const handlePressIn = () => {
    if (!disabled && !isProcessing && hasPermission) {
      startRecording();
    }
  };

  const handlePressOut = () => {
    if (isRecording) {
      stopRecording();
    }
  };

  const getButtonText = () => {
    if (!hasPermission) return 'ÈúÄË¶ÅÊùÉÈôê';
    if (isProcessing) return 'ËØÜÂà´‰∏≠...';
    if (isRecording) return 'ÊùæÂºÄÁªìÊùü';
    return 'Êåâ‰ΩèËØ¥ËØù';
  };

  const getButtonColor = () => {
    if (!hasPermission) return '#999';
    if (isProcessing) return '#FF9500';
    if (isRecording) return '#FF3B30';
    return '#007AFF';
  };

  const getIconName = () => {
    if (!hasPermission) return 'mic-off';
    if (isProcessing) return 'hourglass';
    if (isRecording) return 'stop';
    return 'mic';
  };

  const getStatusText = () => {
    if (!hasPermission) return 'È∫¶ÂÖãÈ£éÊùÉÈôêË¢´ÊãíÁªù';
    if (!speechStatus) return 'Ê£ÄÊü•ÊúçÂä°Áä∂ÊÄÅ...';
    
    if (speechStatus.baiduAvailable) {
      return '‰ΩøÁî®ÁôæÂ∫¶ËØ≠Èü≥API';
    } else if (speechStatus.fallbackAvailable) {
      return '‰ΩøÁî®Ê®°ÊãüËØÜÂà´';
    } else {
      return 'ËØ≠Èü≥ËØÜÂà´‰∏çÂèØÁî®';
    }
  };

  const getConfigStatusText = () => {
    if (!configInfo) return '';
    
    if (configInfo.isConfigured) {
      return 'ÁôæÂ∫¶APIÂ∑≤ÈÖçÁΩÆ';
    } else {
      return 'ÁôæÂ∫¶APIÊú™ÈÖçÁΩÆÔºå‰ΩøÁî®Ê®°ÊãüËØÜÂà´';
    }
  };

  const getDiagnosisText = () => {
    if (!diagnosis) return '';
    
    const issues = [];
    if (diagnosis.audioRecording.issues.length > 0) {
      issues.push(`ÂΩïÈü≥: ${diagnosis.audioRecording.issues[0]}`);
    }
    if (diagnosis.apiStatus.issues.length > 0) {
      issues.push(`API: ${diagnosis.apiStatus.issues[0]}`);
    }
    
    return issues.length > 0 ? issues.join(' | ') : 'ËØäÊñ≠Ê≠£Â∏∏';
  };

  return (
    <Pressable
      style={[styles.container, disabled && styles.disabled]}
      onPressIn={handlePressIn}
      onPressOut={handlePressOut}
      disabled={disabled || isProcessing || !hasPermission}
    >
      <Animated.View
        style={[
          styles.button,
          { backgroundColor: getButtonColor() },
          { transform: [{ scale: pulseAnim }] },
        ]}
      >
        <Ionicons
          name={getIconName() as any}
          size={32}
          color="#FFFFFF"
        />
      </Animated.View>
      <ThemedText style={styles.buttonText}>{getButtonText()}</ThemedText>
      {speechStatus && (
        <ThemedText style={styles.statusText}>{getStatusText()}</ThemedText>
      )}
      {configInfo && (
        <ThemedText style={styles.configText}>{getConfigStatusText()}</ThemedText>
      )}
      {diagnosis && (
        <ThemedText style={styles.diagnosisText}>{getDiagnosisText()}</ThemedText>
      )}
      {error && (
        <ThemedText style={styles.errorText}>{error}</ThemedText>
      )}
      
      {/* Êí≠ÊîæÊµãËØïÊåâÈíÆ */}
      {lastRecordingUri && (
        <TouchableOpacity
          style={[styles.playButton, isPlaying && styles.playButtonActive]}
          onPress={isPlaying ? stopPlaying : playRecording}
          disabled={isProcessing}
        >
          <Ionicons
            name={isPlaying ? "stop" : "play"}
            size={20}
            color="#FFFFFF"
          />
          <ThemedText style={styles.playButtonText}>
            {isPlaying ? 'ÂÅúÊ≠¢Êí≠Êîæ' : 'Êí≠ÊîæÂΩïÈü≥'}
          </ThemedText>
        </TouchableOpacity>
      )}
      
      {/* ËØäÊñ≠ÊåâÈíÆ */}
      <TouchableOpacity
        style={styles.diagnoseButton}
        onPress={diagnoseBaiduAPI}
        disabled={isProcessing}
      >
        <Ionicons
          name="bug"
          size={16}
          color="#FFFFFF"
        />
        <ThemedText style={styles.diagnoseButtonText}>
          ËØäÊñ≠ÁôæÂ∫¶API
        </ThemedText>
      </TouchableOpacity>
    </Pressable>
  );
}

const styles = StyleSheet.create({
  container: {
    justifyContent: 'center',
    alignItems: 'center',
    paddingVertical: 12, // ÂáèÂ∞ëÂûÇÁõ¥Èó¥Ë∑ùÔºå‰ªé20Êîπ‰∏∫12
    paddingBottom: Platform.OS === 'android' ? 0 : 12, // ÂáèÂ∞ëAndroidÂ∫ïÈÉ®Èó¥Ë∑ùÔºå‰ªé20Êîπ‰∏∫12
    zIndex: 1,
  },
  button: {
    width: 80,
    height: 80,
    borderRadius: 40,
    justifyContent: 'center',
    alignItems: 'center',
  },
  disabled: {
    opacity: 0.5,
  },
  buttonText: {
    fontSize: 16,
    color: '#666',
    textAlign: 'center',
    marginTop: 8, // ÂáèÂ∞ëÈ°∂ÈÉ®Èó¥Ë∑ùÔºå‰ªé12Êîπ‰∏∫8
  },
  statusText: {
    fontSize: 12,
    color: '#999',
    textAlign: 'center',
    marginTop: 4,
  },
  errorText: {
    fontSize: 14,
    color: '#FF3B30',
    textAlign: 'center',
    marginTop: 6, // ÂáèÂ∞ëÈ°∂ÈÉ®Èó¥Ë∑ùÔºå‰ªé8Êîπ‰∏∫6
  },
  configText: {
    fontSize: 12,
    color: '#999',
    textAlign: 'center',
    marginTop: 2,
  },
  diagnosisText: {
    fontSize: 12,
    color: '#FF9500',
    textAlign: 'center',
    marginTop: 2,
  },
  playButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: '#007AFF',
    paddingVertical: 10,
    paddingHorizontal: 20,
    borderRadius: 20,
    marginTop: 10,
    width: '80%', // Ë∞ÉÊï¥ÂÆΩÂ∫¶
    alignSelf: 'center',
  },
  playButtonActive: {
    backgroundColor: '#FF3B30',
  },
  playButtonText: {
    color: '#FFFFFF',
    marginLeft: 5,
    fontSize: 14,
  },
  diagnoseButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: '#FF3B30',
    paddingVertical: 10,
    paddingHorizontal: 20,
    borderRadius: 20,
    marginTop: 10,
    width: '80%', // Ë∞ÉÊï¥ÂÆΩÂ∫¶
    alignSelf: 'center',
  },
  diagnoseButtonText: {
    color: '#FFFFFF',
    marginLeft: 5,
    fontSize: 14,
  },
}); 